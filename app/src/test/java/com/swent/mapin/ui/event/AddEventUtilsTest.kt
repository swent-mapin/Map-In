package com.swent.mapin.ui.event

import com.swent.mapin.model.location.Location
import junit.framework.TestCase
import kotlin.test.Test
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue

/**
 * Example local unit test, which will execute on the development machine (host). Generated by AI.
 */
class AddEventUtilsTest {
  @Test
  fun `returns true for blank input`() {
    assertTrue(isValidTagInput(""))
    assertTrue(isValidTagInput("   ")) // whitespace only
  }

  @Test
  fun `returns true for single valid tag`() {
    assertTrue(isValidTagInput("food"))
    assertTrue(isValidTagInput("fun_2025"))
  }

  @Test
  fun `returns true for multiple valid tags separated by commas`() {
    assertTrue(isValidTagInput("food,travel"))
    assertTrue(isValidTagInput("food ,travel"))
    assertTrue(isValidTagInput("food , travel , music"))
  }

  @Test
  fun `returns false for tags missing hash or invalid format`() {
    TestCase.assertFalse(isValidTagInput("#food")) // shouldn't have #
    TestCase.assertFalse(isValidTagInput("food #travel")) // second shouldn't have #
    TestCase.assertFalse(isValidTagInput("food,#travel")) // invalid second
    TestCase.assertFalse(isValidTagInput("#")) // incomplete tag
    TestCase.assertFalse(isValidTagInput("food,,")) // trailing commas
    TestCase.assertFalse(isValidTagInput("food, ")) // dangling #
  }

  // ---------- Tests for extractTags ----------

  @Test
  fun `extracts single tag correctly`() {
    val result = extractTags("#food")
    assertEquals(listOf("#food"), result)
  }

  @Test
  fun `extracts multiple tags with mixed separators`() {
    val result = extractTags("#food , #travel,#music")
    assertEquals(listOf("#food", "#travel", "#music"), result)
  }

  @Test
  fun `returns empty list when no tags present`() {
    val result = extractTags("no tags here")
    assertTrue(result.isEmpty())
  }

  // ---------- Tests for isValidLocation ----------

  @Test
  fun `parseAndValidateStartEnd valid returns success`() {
    val res = parseAndValidateStartEnd("01/01/2025", "1300", "01/01/2025", "1500")
    assertTrue(res is ParseResult.Success)
    val success = res as ParseResult.Success
    // start < end
    assertTrue(success.end.toDate().after(success.start.toDate()))
  }

  @Test
  fun `returns true when location name matches ignoring case`() {
    val locations =
        listOf(
            Location.from("Paris", 0.0, 0.0),
            Location.from("London", 0.0, 0.0),
            Location.from("New York", 0.0, 0.0))
    assertTrue(isValidLocation("paris", locations))
    assertTrue(isValidLocation("LONDON", locations))
  }

  @Test
  fun `returns false when location not in list`() {
    val locations = listOf(Location.from("Berlin", 0.0, 0.0), Location.from("Rome", 0.0, 0.0))
    TestCase.assertFalse(isValidLocation("Madrid", locations))
  }

  @Test
  fun `parseAndValidateStartEnd endBeforeStart returns error`() {
    val res = parseAndValidateStartEnd("01/01/2025", "1500", "01/01/2025", "1400")
    assertTrue(res is ParseResult.Error)
    val err = res as ParseResult.Error
    assertEquals("end must be after start", err.message)
  }

  @Test
  fun `returns false for empty location list`() {
    val locations = emptyList<Location>()
    TestCase.assertFalse(isValidLocation("Anything", locations))
  }

  @Test
  fun `parseAndValidateStartEnd endEqualStart returns error`() {
    val res = parseAndValidateStartEnd("01/01/2025", "1500", "01/01/2025", "1500")
    assertTrue(res is ParseResult.Error)
    val err = res as ParseResult.Error
    assertEquals("end must be after start", err.message)
  }

  @Test
  fun `parseAndValidateStartEnd invalidParse returns error`() {
    val res = parseAndValidateStartEnd("invalid", "abcd", "01/01/2025", "1500")
    assertTrue(res is ParseResult.Error)
    val err = res as ParseResult.Error
    // message could be invalid start datetime
    assertEquals("invalid start datetime", err.message)
  }

  @Test
  fun `returns false for invalid price`() {
    val invalidPrice = "3.0price"
    val invalidPrice2 = "3.0f"
    val invalidPrice3 = "price"
    val invalidPrice4 = "price0.0"
    TestCase.assertFalse(isValidPriceInput(invalidPrice))
    TestCase.assertFalse(isValidPriceInput(invalidPrice2))
    TestCase.assertFalse(isValidPriceInput(invalidPrice3))
    TestCase.assertFalse(isValidPriceInput(invalidPrice4))
  }

  @Test
  fun `returns true for valid price`() {
    val validPrice = "3.0"
    val validPrice2 = "0"
    val validPrice3 = "0.0"
    val validPrice4 = "10"
    TestCase.assertTrue(isValidPriceInput(validPrice))
    TestCase.assertTrue(isValidPriceInput(validPrice2))
    TestCase.assertTrue(isValidPriceInput(validPrice3))
    TestCase.assertTrue(isValidPriceInput(validPrice4))
  }
}
